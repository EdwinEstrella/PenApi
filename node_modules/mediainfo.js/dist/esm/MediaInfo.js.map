{"version":3,"file":"MediaInfo.js","names":["unknownToError","FLOAT_FIELDS","INT_FIELDS","MAX_UINT32_PLUS_ONE","FORMAT_CHOICES","DEFAULT_OPTIONS","coverData","chunkSize","format","full","MediaInfo","isAnalyzing","constructor","mediainfoModule","options","mediainfoModuleInstance","instantiateModuleInstance","analyzeData","size","readChunk","callback","undefined","Promise","resolve","reject","resultCb","result","error","Error","reset","finalize","openBufferFinalize","inform","parseResultJson","offset","runReadDataLoop","fileSize","readNextChunk","data","continueBuffer","getChunk","dataValue","safeSize","Math","min","then","catch","length","openBufferContinue","seekTo","openBufferContinueGotoGet","openBufferInit","fileSizeValue","close","delete","open_buffer_continue","seekToLow","open_buffer_continue_goto_get_lower","seekToHigh","open_buffer_continue_goto_get_upper","open_buffer_finalize","open_buffer_init","resultString","intFields","floatFields","JSON","parse","media","newMedia","track","Array","isArray","newTrack","key","val","Object","entries","includes","Number","parseInt","parseFloat","push"],"sourceRoot":"../../src","sources":["MediaInfo.ts"],"sourcesContent":["import { unknownToError } from './error.js'\nimport { FLOAT_FIELDS, INT_FIELDS, type MediaInfoResult, type Track } from './MediaInfoResult.js'\nimport type { MediaInfoFactoryOptions } from './mediaInfoFactory.js'\nimport type { MediaInfoModule, MediaInfoWasmInterface } from './MediaInfoModule.js'\n\nconst MAX_UINT32_PLUS_ONE = 2 ** 32\n\n/** Format of the result type */\ntype FormatType = 'object' | 'JSON' | 'XML' | 'HTML' | 'text'\n\ntype MediaInfoOptions<TFormat extends FormatType> = Required<\n  Omit<MediaInfoFactoryOptions<TFormat>, 'locateFile'>\n>\n\ntype SizeArg = (() => Promise<number> | number) | number\n\ntype ReadChunkFunc = (size: number, offset: number) => Promise<Uint8Array> | Uint8Array\n\ninterface ResultMap {\n  object: MediaInfoResult\n  JSON: string\n  XML: string\n  HTML: string\n  text: string\n}\n\nconst FORMAT_CHOICES = ['JSON', 'XML', 'HTML', 'text'] as const\n\nconst DEFAULT_OPTIONS = {\n  coverData: false,\n  chunkSize: 256 * 1024,\n  format: 'object',\n  full: false,\n} as const\n\ntype ResultCallback<TFormat extends FormatType> = (\n  result: ResultMap[TFormat] | null,\n  err?: unknown\n) => void\n\n/**\n * Wrapper for the MediaInfoLib WASM module.\n *\n * This class should not be instantiated directly. Use the {@link mediaInfoFactory} function\n * to create instances of `MediaInfo`.\n *\n * @typeParam TFormat - The format type, defaults to `object`.\n */\nclass MediaInfo<TFormat extends FormatType = typeof DEFAULT_OPTIONS.format> {\n  private readonly mediainfoModule: MediaInfoModule\n  private mediainfoModuleInstance: MediaInfoWasmInterface\n  private isAnalyzing = false\n\n  /** @group General Use */\n  readonly options: MediaInfoOptions<TFormat>\n\n  /**\n   * The constructor should not be called directly, instead use {@link mediaInfoFactory}.\n   *\n   * @hidden\n   * @param mediainfoModule WASM module\n   * @param options User options\n   */\n  constructor(mediainfoModule: MediaInfoModule, options: MediaInfoOptions<TFormat>) {\n    this.mediainfoModule = mediainfoModule\n    this.options = options\n    this.mediainfoModuleInstance = this.instantiateModuleInstance()\n  }\n\n  /**\n   * Convenience method for analyzing a buffer chunk by chunk.\n   *\n   * @param size Return total buffer size in bytes.\n   * @param readChunk Read chunk of data and return an {@link Uint8Array}.\n   * @group General Use\n   */\n  analyzeData(size: SizeArg, readChunk: ReadChunkFunc): Promise<ResultMap[TFormat]>\n\n  /**\n   * Convenience method for analyzing a buffer chunk by chunk.\n   *\n   * @param size Return total buffer size in bytes.\n   * @param readChunk Read chunk of data and return an {@link Uint8Array}.\n   * @param callback Function that is called once the processing is done\n   * @group General Use\n   */\n  analyzeData(size: SizeArg, readChunk: ReadChunkFunc, callback: ResultCallback<TFormat>): void\n\n  analyzeData(\n    size: SizeArg,\n    readChunk: ReadChunkFunc,\n    callback?: ResultCallback<TFormat>\n  ): Promise<ResultMap[TFormat] | null> | undefined {\n    // Support promise signature\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        const resultCb: ResultCallback<TFormat> = (result, error) => {\n          this.isAnalyzing = false\n          if (error || !result) {\n            reject(unknownToError(error))\n          } else {\n            resolve(result)\n          }\n        }\n        this.analyzeData(size, readChunk, resultCb)\n      })\n    }\n\n    if (this.isAnalyzing) {\n      callback('', new Error('cannot start a new analysis while another is in progress'))\n      return\n    }\n    this.reset()\n    this.isAnalyzing = true\n\n    const finalize = () => {\n      try {\n        this.openBufferFinalize()\n        const result = this.inform()\n        if (this.options.format === 'object') {\n          callback(this.parseResultJson(result))\n        } else {\n          callback(result)\n        }\n      } finally {\n        this.isAnalyzing = false\n      }\n    }\n\n    let offset = 0\n    const runReadDataLoop = (fileSize: number) => {\n      const readNextChunk = (data: Uint8Array) => {\n        if (continueBuffer(data)) {\n          getChunk()\n        } else {\n          finalize()\n        }\n      }\n\n      const getChunk = () => {\n        let dataValue\n        try {\n          const safeSize = Math.min(this.options.chunkSize, fileSize - offset)\n          dataValue = readChunk(safeSize, offset)\n        } catch (error: unknown) {\n          this.isAnalyzing = false\n          callback('', unknownToError(error))\n          return\n        }\n\n        if (dataValue instanceof Promise) {\n          dataValue.then(readNextChunk).catch((error: unknown) => {\n            this.isAnalyzing = false\n            callback('', unknownToError(error))\n          })\n        } else {\n          readNextChunk(dataValue)\n        }\n      }\n\n      const continueBuffer = (data: Uint8Array): boolean => {\n        if (data.length === 0 || this.openBufferContinue(data, data.length)) {\n          return false\n        }\n        const seekTo: number = this.openBufferContinueGotoGet()\n        if (seekTo === -1) {\n          offset += data.length\n        } else {\n          offset = seekTo\n          this.openBufferInit(fileSize, seekTo)\n        }\n        return true\n      }\n\n      this.openBufferInit(fileSize, offset)\n      getChunk()\n    }\n\n    const fileSizeValue = typeof size === 'function' ? size() : size\n\n    if (fileSizeValue instanceof Promise) {\n      fileSizeValue.then(runReadDataLoop).catch((error: unknown) => {\n        callback(null, unknownToError(error))\n      })\n    } else {\n      runReadDataLoop(fileSizeValue)\n    }\n  }\n\n  /**\n   * Close the MediaInfoLib WASM instance.\n   *\n   * @group General Use\n   */\n  close(): void {\n    if (typeof this.mediainfoModuleInstance.close === 'function') {\n      this.mediainfoModuleInstance.close()\n    }\n  }\n\n  /**\n   * Reset the MediaInfoLib WASM instance to its initial state.\n   *\n   * This method ensures that the instance is ready for a new parse.\n   * @group General Use\n   */\n  reset(): void {\n    this.mediainfoModuleInstance.delete()\n    this.mediainfoModuleInstance = this.instantiateModuleInstance()\n  }\n\n  /**\n   * Receive result data from the WASM instance.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @returns Result data (format can be configured in options)\n   * @group Low-level\n   */\n  inform(): string {\n    return this.mediainfoModuleInstance.inform()\n  }\n\n  /**\n   * Send more data to the WASM instance.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @param data Data buffer\n   * @param size Buffer size\n   * @returns Processing state: `0` (no bits set) = not finished, Bit `0` set = enough data read for providing information\n   * @group Low-level\n   */\n  openBufferContinue(data: Uint8Array, size: number): boolean {\n    // bit 3 set -> done\n    return !!(this.mediainfoModuleInstance.open_buffer_continue(data, size) & 0x08)\n  }\n\n  /**\n   * Retrieve seek position from WASM instance.\n   * The MediaInfoLib function `Open_Buffer_GoTo` returns an integer with 64 bit precision.\n   * It would be cut at 32 bit due to the JavaScript bindings. Here we transport the low and high\n   * parts separately and put them together.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @returns Seek position (where MediaInfoLib wants go in the data buffer)\n   * @group Low-level\n   */\n  openBufferContinueGotoGet(): number {\n    // JS bindings don't support 64 bit int\n    // https://github.com/buzz/mediainfo.js/issues/11\n    let seekTo = -1\n    const seekToLow: number = this.mediainfoModuleInstance.open_buffer_continue_goto_get_lower()\n    const seekToHigh: number = this.mediainfoModuleInstance.open_buffer_continue_goto_get_upper()\n    if (seekToLow == -1 && seekToHigh == -1) {\n      seekTo = -1\n    } else if (seekToLow < 0) {\n      seekTo = seekToLow + MAX_UINT32_PLUS_ONE + seekToHigh * MAX_UINT32_PLUS_ONE\n    } else {\n      seekTo = seekToLow + seekToHigh * MAX_UINT32_PLUS_ONE\n    }\n    return seekTo\n  }\n\n  /**\n   * Inform MediaInfoLib that no more data is being read.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @group Low-level\n   */\n  openBufferFinalize(): void {\n    this.mediainfoModuleInstance.open_buffer_finalize()\n  }\n\n  /**\n   * Prepare MediaInfoLib to process a data buffer.\n   *\n   * (This is a low-level MediaInfoLib function.)\n   *\n   * @param size Expected buffer size\n   * @param offset Buffer offset\n   * @group Low-level\n   */\n  openBufferInit(size: number, offset: number): void {\n    this.mediainfoModuleInstance.open_buffer_init(size, offset)\n  }\n\n  /**\n   * Parse result JSON. Convert integer/float fields.\n   *\n   * @param result Serialized JSON from MediaInfo\n   * @returns Parsed JSON object\n   */\n  private parseResultJson(resultString: string): ResultMap[TFormat] {\n    type Writable<T> = { -readonly [P in keyof T]: T[P] }\n\n    const intFields = INT_FIELDS as readonly string[]\n    const floatFields = FLOAT_FIELDS as readonly string[]\n\n    // Parse JSON\n    const result = JSON.parse(resultString) as MediaInfoResult\n\n    if (result.media) {\n      const newMedia = { ...result.media, track: [] as Writable<Track>[] }\n\n      if (Array.isArray(result.media.track)) {\n        for (const track of result.media.track) {\n          let newTrack: Writable<Track> = { '@type': track['@type'] }\n          for (const [key, val] of Object.entries(track) as [string, unknown][]) {\n            if (key === '@type') {\n              continue\n            }\n            if (typeof val === 'string' && intFields.includes(key)) {\n              newTrack = { ...newTrack, [key]: Number.parseInt(val, 10) }\n            } else if (typeof val === 'string' && floatFields.includes(key)) {\n              newTrack = { ...newTrack, [key]: Number.parseFloat(val) }\n            } else {\n              newTrack = { ...newTrack, [key]: val }\n            }\n          }\n          newMedia.track.push(newTrack)\n        }\n      }\n\n      return { ...result, media: newMedia } as ResultMap[TFormat]\n    }\n\n    return result as ResultMap[TFormat]\n  }\n\n  /**\n   * Instantiate a new WASM module instance.\n   *\n   * @returns MediaInfo module instance\n   */\n  private instantiateModuleInstance(): MediaInfoWasmInterface {\n    return new this.mediainfoModule.MediaInfo(\n      this.options.format === 'object' ? 'JSON' : this.options.format,\n      this.options.coverData,\n      this.options.full\n    )\n  }\n}\n\nexport type { FormatType, ReadChunkFunc, ResultMap, SizeArg }\nexport { DEFAULT_OPTIONS, FORMAT_CHOICES }\nexport default MediaInfo\n"],"mappings":"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","ignoreList":[]}